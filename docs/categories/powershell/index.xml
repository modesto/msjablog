<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PowerShell on Blog de Modesto San Juan</title>
    <link>http://www.modestosanjuan.com/categories/powershell/</link>
    <description>Recent content in PowerShell on Blog de Modesto San Juan</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <lastBuildDate>Wed, 25 Nov 2015 09:16:48 +0000</lastBuildDate><atom:link href="http://www.modestosanjuan.com/categories/powershell/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[PowerShell] Pasar de SecureString a String</title>
      <link>http://www.modestosanjuan.com/powershell-pasar-de-securestring-a-string/</link>
      <pubDate>Wed, 25 Nov 2015 09:16:48 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-pasar-de-securestring-a-string/</guid>
      <description>En ocasiones necesito usar un SecureString pero luego me veo obligado a utilizar ese string de forma no segura. Aunque la recomendación es no hacer esto, la realidad es que hay muchos escenarios en los que es necesario. Un ejemplo sencillo es el caso en el que necesito que el usuario meta un dato sensible por consola y pero luego necesito utilizar ese dato como texto plano para pasarlo como parámetro a un ejecutable de Windows.</description>
    </item>
    
    <item>
      <title>[PowerShell] Sacando partido a la conversión de tipos</title>
      <link>http://www.modestosanjuan.com/powershell-sacando-partido-a-la-conversion-de-tipos/</link>
      <pubDate>Thu, 22 Oct 2015 00:27:51 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-sacando-partido-a-la-conversion-de-tipos/</guid>
      <description>PowerShell ETS (Extended Type System) forma parte de las tripas de PowerShell y es la parte que permite que convivan tipos de .Net, COM, ADSI y WMI pero que a nosotros se nos muestren como objetos de PowerShell de primer orden.
ETS tiene mucha potencia y no siempre es fácil obtener documentación sobre cómo hacer las cosas, pero en este post quiero dejarle a mi yo futuro un regalito para cuando necesite realizar conversión de tipos de .</description>
    </item>
    
    <item>
      <title>[PowerShell] Distinguir entre rutas relativas y absolutas</title>
      <link>http://www.modestosanjuan.com/powershell-distinguir-entre-rutas-relativas-y-absolutas/</link>
      <pubDate>Thu, 08 Oct 2015 22:41:43 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-distinguir-entre-rutas-relativas-y-absolutas/</guid>
      <description>Esta vez toca un truco muy simple pero muy útil cuando tengo un script que recibe una ruta como parámetro. Es muy típico no saber si la ruta es absoluta o relativa y muy frecuente querer hacer un Join-Path con la ruta actual (o cualquier otra) en caso de que la ruta sea relativa.
En ocasiones me olvido de que PowerShell tiene a su disposición toda la potencia de .Net y en este caso es precisamente útil.</description>
    </item>
    
    <item>
      <title>[PowerShell] Variables automáticas</title>
      <link>http://www.modestosanjuan.com/powershell-variables-automaticas/</link>
      <pubDate>Sun, 20 Sep 2015 22:10:01 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-variables-automaticas/</guid>
      <description>PowerShell dispone de una serie de variables gestionadas de forma automática que permiten obtener información relacionada con la ejecución de código actual. Su propósito y utilidad es variado, siendo algunas de uso muy frecuente y otras de uso marginal. En cualquier caso, no está mal conocer unas cuantas y que suene dentro de la cabeza que hay otras que tal vez sea útiles en el futuro.
Tanto la documentación oficial como el comando “get-help about_automatic_variables“ contienen el listado completo, pero me gustaría enumerar por aquí algunas que me resultan interesantes o que tienen truco.</description>
    </item>
    
    <item>
      <title>[PowerShell] Ojo que no hay un único $null</title>
      <link>http://www.modestosanjuan.com/powershell-ojo-que-no-hay-un-unico-null/</link>
      <pubDate>Wed, 09 Sep 2015 20:49:56 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-ojo-que-no-hay-un-unico-null/</guid>
      <description>Este es un ejemplo curioso de esos que me ha vuelto loco hasta que me he dado cuenta. Si parto de este código:
$item1 = Get-ChildItem | Where-Object {$_ -eq &#34;no encuentras esto ni de coña&#34;}&#34;item1 es nulo? {0}&#34; -f ($null -eq $item1)$item2 = $null&#34;item2 es nulo? {0}&#34; -f ($null -eq $item2)Al ejecutarlo el resultado es “True” en ambos casos. Vamos, que tanto item1 como item2 son $null.</description>
    </item>
    
    <item>
      <title>[PowerShell] Saber si una variable ya ha sido definida</title>
      <link>http://www.modestosanjuan.com/powershell-saber-si-una-variable-ya-ha-sido-definida/</link>
      <pubDate>Thu, 20 Aug 2015 22:14:23 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-saber-si-una-variable-ya-ha-sido-definida/</guid>
      <description>En ocasiones tengo la necesidad de saber si una variable ha sido previamente definida. Esto es especialmente importante porque utilizo siempre el “Set-StrictMode -Version 2” y, si necesito recurrir a variables de otros scopes, cuando intento acceder a una variable no definida obtengo un error. Aunque generalmente intento no recurrir a otros scopes, especialmente el $global, en ocasiones los necesito, especialmente el $script.
Un ejemplo podría ser querer verificar si una variable que contiene un array ha sido inicializada o no, para poder añadirle ítems.</description>
    </item>
    
    <item>
      <title>[PowerShell] Devolver un array vacío desde una función</title>
      <link>http://www.modestosanjuan.com/powershell-devolver-un-array-vacio-desde-una-funcion/</link>
      <pubDate>Thu, 20 Aug 2015 15:07:23 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-devolver-un-array-vacio-desde-una-funcion/</guid>
      <description>Esto es un truco rápido muy chorra pero que puede volver loco a más de un desarrollador que no esté acostumbrado a las peculiaridades de PowerShell. Tomando este código como ejemplo:
function Get-EmptyArray {[System.Collections.ArrayList]$anyArray = @()return $anyArray }Write-Host (Get-EmptyArray).GetType()En principio podría resultar bastante evidente que el resultado de la ejecución será ver por pantalla la cadena “System.Collections.Arraylist”. Pues no, el resultado será un error como una casa del estilo de “You cannot call a method on a null-valued expression”</description>
    </item>
    
    <item>
      <title>[PowerShell] Las ventajas de usar parámetros y variables tipados</title>
      <link>http://www.modestosanjuan.com/powershell-las-ventajas-de-usar-parametros-y-variables-tipados/</link>
      <pubDate>Tue, 18 Aug 2015 09:52:05 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-las-ventajas-de-usar-parametros-y-variables-tipados/</guid>
      <description>Cuanto más uso PowerShell más convencido estoy de lo importante que es tipar las variables y los parámetros de las funciones. Debido a la forma en que trabaja PowerShell, especificar los tipos me ayuda a evitar comportamientos indeseados.
Por ejemplo, dado este script:
Set-StrictMode -Version 2$items = Get-ChildItemif ($items) {$items.Count}Si lo ejecuto estando en un directorio con varios archivos o carpetas, mostrará en pantalla el número de items.</description>
    </item>
    
    <item>
      <title>[PowerShell] Switch parameters</title>
      <link>http://www.modestosanjuan.com/powershell-switch-parameters/</link>
      <pubDate>Mon, 17 Aug 2015 22:37:14 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-switch-parameters/</guid>
      <description>En PowerShell es muy común usar parámetros de tipo switch. La peculiaridad de estos parámetros es que al usarlos, se especifica el nombre del parámetro pero no se proporciona ningún valor, ya que se asume que al usarlo su valor será $true y $false si no se especifica. Ejemplos típicos son el uso de –_Recurse o -Force. _
Este sería un ejemplo de con este tipo de parámetros:
Function Do-Something([Switch]$Recurse) {Write-Host $Recurse}Do-Something -RecurseDo-SomethingSi ejecuto este script, veré por pantalla $True y $False, como podría esperar.</description>
    </item>
    
    <item>
      <title>[PowerShell] Cuidado que ($a -eq $a) no siempre es $true</title>
      <link>http://www.modestosanjuan.com/powershell-cuidado-que-a-eq-a-no-siempre-es-true/</link>
      <pubDate>Fri, 07 Aug 2015 00:22:46 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-cuidado-que-a-eq-a-no-siempre-es-true/</guid>
      <description>Este es uno de esos ejemplos en los que es importante intentar documentarse todo lo posible al desarrollar en un lenguaje/plataforma que no conocemos. Es frecuente asumir conceptos basados en nuestros conocimientos previos de otros lenguajes, pero en ocasiones nos puede jugar malas pasadas. En este caso voy a mostrar un ejemplo muy sencillo en el que yo asumí erróneamente el funcionamiento de algo tan sencillo como un operador de comparación.</description>
    </item>
    
    <item>
      <title>[PowerShell] Crear el fichero de manifiesto para muchos módulos a la vez</title>
      <link>http://www.modestosanjuan.com/powershell-crear-el-fichero-de-manifiesto-para-muchos-modulos-a-la-vez/</link>
      <pubDate>Wed, 05 Aug 2015 13:50:27 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-crear-el-fichero-de-manifiesto-para-muchos-modulos-a-la-vez/</guid>
      <description>Hoy he tenido que crear de golpe el manifest a varios módulos. Teníamos más de 10 módulos (.psm1), cada uno en su propia carpeta y necesitaba añadirles el manifest para poder definir la empresa de cada módulo. Gracias al pipeline de PowerShell, no he tenido que esforzarme mucho para conseguirlo:
ls *.psm1 -Recurse | ForEach-Object { $manifestFileName = $_.BaseName + &#34;.psd1&#34;$manifestPath = Join-Path $_.Directory $manifestFileName$companyConstant = &#34;AnyCompany&#34;New-ModuleManifest -Path $manifestPath -RootModule $_.</description>
    </item>
    
    <item>
      <title>[PowerShell] La importancia del Set-StrictMode</title>
      <link>http://www.modestosanjuan.com/powershell-la-importancia-del-set-strictmode/</link>
      <pubDate>Mon, 03 Aug 2015 23:50:39 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/powershell-la-importancia-del-set-strictmode/</guid>
      <description>Cuando empecé a programar scripts en PowerShell, cometía muchísimos fallos fruto de mi intoxicación con otros lenguajes, especialmente C#, con el que trabajo habitualmente. Después de un tiempo, me di cuenta que PowerShell tiene muchas más similitudes con JavaScript que con C# ya que es un lenguaje interpretado y de tipado débil. Y un tiempo después, aprendí que podía programar en PowerShell de una manera más próxima a TypeScript.
Lo explico de esta forma porque a mi cerebro le resulta más sencillo recurrir a este paralelismo.</description>
    </item>
    
    <item>
      <title>[PowerShell] Evitar que wget (Invoke-WebRequest) tarde tanto</title>
      <link>http://www.modestosanjuan.com/truco-evitar-que-wget-invoke-webrequest-tarde-tanto-en-powershell/</link>
      <pubDate>Sun, 22 Mar 2015 19:18:44 +0000</pubDate>
      
      <guid>http://www.modestosanjuan.com/truco-evitar-que-wget-invoke-webrequest-tarde-tanto-en-powershell/</guid>
      <description>Mientras estaba preparando unos scripts para automatizar el proceso de sideloading de una aplicación Windows 8.1, me encontré con un problema bastante tonto. Estaba descargando por HTTP el paquete de la aplicación desde una red local pero el comando wget de PowerShell tardaba demasiado. Tenía claro que no era problema de la red porque el archivo bajaba a buena velocidad por otros medios, pero siempre que usaba wget el comando tardaba demasiado tiempo.</description>
    </item>
    
  </channel>
</rss>
